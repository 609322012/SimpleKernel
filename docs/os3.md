# 内存段页机制

我们前面提到，CPU在启动过程中要从实模式转变到保护模式，其原因是因为实模式具有很大弊端，实模式下的用户程序可以破坏存储代码的内存区域，所以要添加个内存段类型属性来阻止这种行为。实模式下的用户程序和操作系统是同一级别的，所以要添加个特权级属性来区分用户程序和操作系统的地位。其次，实模式下的寻址空间只有16位寻址，所以为了解决这些问题，保护模式应运而生。  

我们知道，对CPU来讲，系统中的所有储存器中的储存单元都处于一个统一的逻辑储存器中，它的容量受CPU寻址能力的限制。这个逻辑储存器就是我们所说的线性地址空间。8086有20位地址线，拥有1MB的线性地址空间。而80386有32位地址线，拥有4GB的线性地址空间。但是80386依旧保留了8086采用的地址分段的方式，只是增加了一个折中的方案，即只分一个段，段基址0×00000000，段长0xFFFFFFFF（4GB）也是基地址加偏移地址的策略，这样的话整个线性空间可以看作就一个段，这就是所谓的平坦模型（Flat Mode）。

**实模式下的分段策略：**

在实模式对于内存段并没有访问控制，而且用户所指向的都是真正的物理地址，也就是逻辑地址和物理地址相同，实实在在的指哪打哪，能够实现对任意的程序可以修改任意地址的变量，所以就对于用户模式下就十分危险，如果用户不小心将操作系统内核的数据篡改了那么就会造成非常严重的后果。所以就需要有保护模式，使得物理地址不能被直接访问，而是要通过程序的地址（即虚拟地址）转化为物理地址后再去访问，而程序本身对此一无所知，这样就能大大提高程序的安全性。这个过程是软硬件协同实现的，CPU负责提供地址转换的部件，而操作系统提供转换需要的页表。而保护模式需要对内存段的性质和允许的操作给出定义，以实现对特定内存段的访问检测和数据保护。考虑到各种属性和需要设置的操作，32位保护模式下对一个内存段的描述需要8个字节，其称之为段描述符（Segment Descriptor）。段描述符分为数据段描述符、指令段描述符和系统段描述符三种，这几个描述符可以方便的把操作系统的各种功能相对独立的放置在多个内存中，这样有利于管理程序，而这些描述符会存在一个叫做全局描述符表（GDT）中，一个CPU只能有一个全局描述符表。下面介绍一下这个全局描述符表，也就是说，为了实现保护模式所以就需要这样一个GDT来作为辅助工具。



#### **全局描述符表GDT（Global Descriptor Table）**

在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个**寄存器GDTR**用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过**LGDT指令**将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。

<img src=".\images\gdtr.jpg" alt="gdtr" style="zoom:100%;" />

通过将GDT告诉给CPU后，CPU就知道了操作系统中段的设置，从而可以通过段选择子得到线性地址，在后面实现分页管理后，可进一步将线性地址转换为物理地址（不过当前连物理址有多大都没法知道，在后面会解决）。

除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT（Local Descriptor Table，局部描述符表），但与GDT不同的是，LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。





